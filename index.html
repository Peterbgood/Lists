<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My To-Do Lists</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .offcanvas-body {
            padding: 0;
        }
        .list-group-item, .list-item {
            cursor: move;
        }
        .list-group-item.dragging, .list-item.dragging {
            background-color: #e9ecef;
            opacity: 0.9;
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transition: transform 0.1s ease, opacity 0.1s ease;
        }
        .offcanvas-title {
            cursor: pointer;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .offcanvas-title input {
            border: 1px solid #ced4da;
            border-radius: .25rem;
            padding: 0.25rem 0.5rem;
            width: 75%;
        }
        .list-group-item input {
            border: none;
            background: transparent;
            font-weight: bold;
            font-size: 1.25rem;
            width: 100%;
        }
        .list-group-item .list-item-text {
            cursor: pointer;
        }
        .add-item-form {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .item-text, .list-name {
            flex-grow: 1;
        }
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: move;
            transition: background-color 0.2s ease-in-out;
        }
        .list-item:hover {
            background-color: #dee2e6;
        }
        .list-item .item-actions {
            display: flex;
            gap: 5px;
            visibility: hidden;
        }
        .list-item:hover .item-actions {
            visibility: visible;
        }
        .list-group-item .list-actions {
            display: flex;
            gap: 5px;
            visibility: hidden;
        }
        .list-group-item:hover .list-actions {
            visibility: visible;
        }
        .item-actions .btn, .list-actions .btn {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
        }
        .list-item-container {
            margin-top: 20px;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        #itemsList {
            padding-left: 0;
        }
        .import-export-buttons {
            padding: 1rem;
            border-top: 1px solid #e9ecef;
        }
    </style>
</head>
<body>

    <div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvasLists" aria-labelledby="offcanvasListsLabel">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="offcanvasListsLabel">Your Lists</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
        </div>
        <div class="offcanvas-body">
            <div class="input-group p-3 border-bottom">
                <input type="text" class="form-control" id="newListName" placeholder="Add new list...">
                <button class="btn btn-primary" id="addListBtn"><i class="fas fa-plus"></i></button>
            </div>
            <ul class="list-group list-group-flush" id="listsMenu">
            </ul>
            <div class="import-export-buttons d-flex justify-content-center gap-2">
                <button class="btn btn-secondary" id="exportBtn"><i class="fas fa-download me-1"></i>Export Data</button>
                <button class="btn btn-secondary" id="importBtn"><i class="fas fa-upload me-1"></i>Import Data</button>
                <input type="file" id="importFile" class="d-none" accept="application/json">
            </div>
        </div>
    </div>

    <div class="container py-4">
        <header class="d-flex justify-content-between align-items-center mb-4">
            <h1 class="text-center mb-0 text-primary flex-grow-1" id="headerListName"></h1>
            <button class="btn btn-outline-primary" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasLists" aria-controls="offcanvasLists">
                <i class="fas fa-bars"></i> Lists
            </button>
        </header>
        
        <div id="mainContent" class="list-item-container">
            <div id="currentListHeader" class="d-flex justify-content-between align-items-center mb-3">
                <div></div> <!-- Placeholder for layout consistency -->
                <div>
                    <button class="btn btn-sm btn-outline-secondary edit-list-name-btn" title="Edit List Name"><i class="fas fa-edit"></i></button>
                    <button class="btn btn-sm btn-outline-danger delete-list-btn" title="Delete List"><i class="fas fa-trash-alt"></i></button>
                </div>
            </div>
            <ul class="list-items" id="itemsList">
            </ul>
            <div class="add-item-form mt-auto">
                <input type="text" class="form-control add-item-input" placeholder="Add new item...">
                <button class="btn btn-success btn-add-item"><i class="fas fa-plus"></i></button>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let todoData = { lists: [], items: [] };
        let currentListId = null;

        const listsMenu = document.getElementById('listsMenu');
        const newListNameInput = document.getElementById('newListName');
        const addListBtn = document.getElementById('addListBtn');
        const itemsList = document.getElementById('itemsList');
        const headerListName = document.getElementById('headerListName');
        const addItemInput = document.querySelector('.add-item-input');
        const addItemBtn = document.querySelector('.btn-add-item');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importFile = document.getElementById('importFile');
        const deleteListBtn = document.querySelector('.delete-list-btn');
        const editListNameBtn = document.querySelector('.edit-list-name-btn');

        let draggedElement = null;
        let isDragging = false;

        // Function to save data to local storage
        function saveData() {
            localStorage.setItem('todoData', JSON.stringify(todoData));
        }

        // Function to load data from local storage or use empty data
        function loadData() {
            const savedData = localStorage.getItem('todoData');
            if (savedData) {
                todoData = JSON.parse(savedData);
            }
            sortData();
            renderListsMenu();
            if (todoData.lists.length > 0) {
                switchToList(todoData.lists[0].id);
            }
        }

        // Sort lists and items by their position property
        function sortData() {
            todoData.lists.sort((a, b) => a.position - b.position);
            todoData.items.sort((a, b) => a.position - b.position);
        }

        // Render the lists in the hamburger menu
        function renderListsMenu() {
            listsMenu.innerHTML = '';
            todoData.lists.forEach(list => {
                const listHtml = createListMenuItem(list);
                listsMenu.appendChild(listHtml);
            });
            addListDragListeners();
        }

        // Create a single list menu item
        function createListMenuItem(list) {
            const listItem = document.createElement('li');
            listItem.className = 'list-group-item d-flex justify-content-between align-items-center';
            listItem.setAttribute('data-list-id', list.id);
            listItem.setAttribute('draggable', 'true');
            listItem.innerHTML = `
                <i class="fas fa-grip-vertical me-2"></i>
                <span class="list-name">${list.name}</span>
                <div class="list-actions">
                    <button class="btn btn-sm btn-info edit-list-btn" title="Edit List Name"><i class="fas fa-edit"></i></button>
                    <button class="btn btn-sm btn-danger delete-list-btn-menu" title="Delete List"><i class="fas fa-trash-alt"></i></button>
                </div>
            `;
            listItem.addEventListener('click', (e) => {
                // Prevent switching list when clicking edit/delete buttons or dragging
                if (e.target.closest('.list-actions') || isDragging) {
                    e.stopPropagation();
                    return;
                }
                switchToList(list.id);
            });
            return listItem;
        }

        // Switch to and render a specific list
        function switchToList(listId) {
            currentListId = listId;
            const list = todoData.lists.find(l => l.id === listId);
            if (list) {
                headerListName.textContent = `${list.name} ðŸ“`;
                renderItems(listId);
            }
            // Close the offcanvas menu on mobile
            const offcanvas = bootstrap.Offcanvas.getInstance(document.getElementById('offcanvasLists'));
            if (offcanvas) {
                offcanvas.hide();
            }
        }
        
        // Render the items for the current list
        function renderItems(listId) {
            itemsList.innerHTML = '';
            const listItems = todoData.items.filter(item => item.list_id === listId);
            listItems.forEach(item => {
                const itemHtml = createItemHtml(item);
                itemsList.appendChild(itemHtml);
            });
            addItemDragListeners();
        }

        // Create HTML for a single item
        function createItemHtml(item) {
            const listItem = document.createElement('li');
            listItem.className = 'list-item';
            listItem.setAttribute('data-item-id', item.id);
            listItem.setAttribute('draggable', 'true');
            listItem.innerHTML = `
                <i class="fas fa-grip-vertical me-2"></i>
                <span class="item-text">${item.text}</span>
                <div class="item-actions">
                    <button class="btn btn-sm btn-info edit-item-btn" title="Edit Item"><i class="fas fa-pencil-alt"></i></button>
                    <button class="btn btn-sm btn-danger delete-item-btn" title="Delete Item"><i class="fas fa-trash"></i></button>
                </div>
            `;
            return listItem;
        }

        // Add event listeners for CRUD operations
        function addEventListeners() {
            // Add new list
            addListBtn.addEventListener('click', () => {
                const name = newListNameInput.value.trim();
                if (name) {
                    addList(name);
                    newListNameInput.value = '';
                }
            });

            // Add new list on Enter key
            newListNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const name = newListNameInput.value.trim();
                    if (name) {
                        addList(name);
                        newListNameInput.value = '';
                    }
                }
            });

            // Add new item
            addItemBtn.addEventListener('click', () => {
                const text = addItemInput.value.trim();
                if (text && currentListId !== null) {
                    addItem(currentListId, text);
                    addItemInput.value = '';
                }
            });

            // Add new item on Enter key
            addItemInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const text = addItemInput.value.trim();
                    if (text && currentListId !== null) {
                        addItem(currentListId, text);
                        addItemInput.value = '';
                    }
                }
            });

            // Edit and Delete List/Item
            document.addEventListener('click', (e) => {
                // Edit List Name in main view
                if (e.target.closest('.edit-list-name-btn') && currentListId !== null) {
                    toggleInLineEdit('list', currentListId);
                }
                // Delete List from main view
                if (e.target.closest('.delete-list-btn') && currentListId !== null) {
                    deleteList(currentListId);
                }
                // Edit List from menu
                if (e.target.closest('.edit-list-btn')) {
                    const listId = parseInt(e.target.closest('.list-group-item').dataset.listId);
                    toggleInLineEdit('list', listId);
                }
                // Delete List from menu
                if (e.target.closest('.delete-list-btn-menu')) {
                    const listId = parseInt(e.target.closest('.list-group-item').dataset.listId);
                    deleteList(listId);
                }
                // Edit Item
                if (e.target.closest('.edit-item-btn')) {
                    const itemId = parseInt(e.target.closest('.list-item').dataset.itemId);
                    toggleInLineEdit('item', itemId);
                }
                // Delete Item
                if (e.target.closest('.delete-item-btn')) {
                    const itemId = parseInt(e.target.closest('.list-item').dataset.itemId);
                    deleteItem(itemId);
                }
            });

            // Export data
            exportBtn.addEventListener('click', exportData);
            
            // Import data
            importBtn.addEventListener('click', () => importFile.click());
            importFile.addEventListener('change', importData);
        }

        // Toggle in-line editing for list or item
        function toggleInLineEdit(type, id) {
            if (type === 'list') {
                const list = todoData.lists.find(l => l.id === id);
                if (!list) return;

                const originalName = headerListName.textContent.replace(' ðŸ“', '');
                const input = document.createElement('input');
                input.type = 'text';
                input.value = originalName;
                input.className = 'form-control';
                
                headerListName.innerHTML = '';
                headerListName.appendChild(input);
                input.focus();

                const saveEdit = () => {
                    const newName = input.value.trim();
                    if (newName && newName !== originalName) {
                        editList(id, newName);
                        headerListName.textContent = `${newName} ðŸ“`;
                    } else {
                        headerListName.textContent = `${originalName} ðŸ“`;
                    }
                    if (currentListId === id) {
                        headerListName.textContent = `${newName || originalName} ðŸ“`;
                    }
                };

                input.addEventListener('blur', saveEdit);
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        saveEdit();
                    }
                });
            } else if (type === 'item') {
                const item = todoData.items.find(i => i.id === id);
                if (!item) return;

                const itemElement = document.querySelector(`.list-item[data-item-id="${id}"]`);
                const itemTextSpan = itemElement.querySelector('.item-text');
                const originalText = itemTextSpan.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = originalText;
                
                itemTextSpan.innerHTML = '';
                itemTextSpan.appendChild(input);
                input.focus();

                const saveEdit = () => {
                    const newText = input.value.trim();
                    if (newText && newText !== originalText) {
                        editItem(id, newText);
                    }
                    itemTextSpan.innerHTML = newText;
                };

                input.addEventListener('blur', saveEdit);
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        saveEdit();
                    }
                });
            }
        }

        // Add drag-and-drop listeners for lists
        function addListDragListeners() {
            const listItems = listsMenu.querySelectorAll('.list-group-item');
            listItems.forEach(item => {
                // Desktop Drag & Drop
                item.addEventListener('dragstart', (e) => {
                    isDragging = true;
                    draggedElement = item;
                    e.dataTransfer.setData('text/plain', item.dataset.listId);
                    setTimeout(() => item.classList.add('dragging'), 0);
                });

                item.addEventListener('dragend', () => {
                    if (draggedElement) {
                        draggedElement.classList.remove('dragging');
                        updateListPositions();
                        saveData();
                        draggedElement = null;
                        isDragging = false;
                    }
                });

                // Mobile Touch Drag & Drop
                let startY = 0;
                let startTime = 0;
                let touchMoved = false;

                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    startY = e.touches[0].clientY;
                    startTime = Date.now();
                    touchMoved = false;
                    draggedElement = item;
                    draggedElement.classList.add('dragging');
                });

                item.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    touchMoved = true;
                    const currentY = e.touches[0].clientY;
                    const deltaY = currentY - startY;

                    // Move the element visually
                    draggedElement.style.transform = `translateY(${deltaY}px)`;

                    // Find the element to insert after
                    const afterElement = getDragAfterElement(listsMenu, currentY);
                    if (draggedElement && draggedElement !== afterElement) {
                        if (afterElement == null) {
                            listsMenu.appendChild(draggedElement);
                        } else {
                            listsMenu.insertBefore(draggedElement, afterElement);
                        }
                    }
                }, { passive: false });

                item.addEventListener('touchend', () => {
                    if (draggedElement) {
                        draggedElement.style.transform = '';
                        draggedElement.classList.remove('dragging');
                        if (touchMoved) {
                            updateListPositions();
                            saveData();
                        } else if (Date.now() - startTime < 500) {
                            // Treat as a tap if no movement and short duration
                            switchToList(parseInt(draggedElement.dataset.listId));
                        }
                        draggedElement = null;
                        isDragging = false;
                    }
                });
            });

            listsMenu.addEventListener('dragover', (e) => {
                e.preventDefault();
                const afterElement = getDragAfterElement(listsMenu, e.clientY);
                const draggable = document.querySelector('.list-group-item.dragging');
                if (draggable) {
                    if (afterElement == null) {
                        listsMenu.appendChild(draggable);
                    } else {
                        listsMenu.insertBefore(draggable, afterElement);
                    }
                }
            });

            listsMenu.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedElement) {
                    updateListPositions();
                    saveData();
                }
            });
        }

        // Add drag-and-drop listeners for items
        function addItemDragListeners() {
            const listItems = itemsList.querySelectorAll('.list-item');
            listItems.forEach(item => {
                // Desktop Drag & Drop
                item.addEventListener('dragstart', (e) => {
                    isDragging = true;
                    draggedElement = item;
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        itemId: item.dataset.itemId,
                        sourceListId: currentListId
                    }));
                    setTimeout(() => item.classList.add('dragging'), 0);
                });

                item.addEventListener('dragend', () => {
                    if (draggedElement) {
                        draggedElement.classList.remove('dragging');
                        updateItemPositions();
                        saveData();
                        draggedElement = null;
                        isDragging = false;
                    }
                });

                // Mobile Touch Drag & Drop
                let startY = 0;
                let startTime = 0;
                let touchMoved = false;

                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    startY = e.touches[0].clientY;
                    startTime = Date.now();
                    touchMoved = false;
                    draggedElement = item;
                    draggedElement.classList.add('dragging');
                });

                item.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    touchMoved = true;
                    const currentY = e.touches[0].clientY;
                    const deltaY = currentY - startY;

                    // Move the element visually
                    draggedElement.style.transform = `translateY(${deltaY}px)`;

                    // Find the element to insert after
                    const afterElement = getDragAfterElement(itemsList, currentY);
                    if (draggedElement && draggedElement !== afterElement) {
                        if (afterElement == null) {
                            itemsList.appendChild(draggedElement);
                        } else {
                            itemsList.insertBefore(draggedElement, afterElement);
                        }
                    }
                }, { passive: false });

                item.addEventListener('touchend', () => {
                    if (draggedElement) {
                        draggedElement.style.transform = '';
                        draggedElement.classList.remove('dragging');
                        if (touchMoved) {
                            updateItemPositions();
                            saveData();
                        }
                        draggedElement = null;
                        isDragging = false;
                    }
                });
            });

            itemsList.addEventListener('dragover', (e) => {
                e.preventDefault();
                const afterElement = getDragAfterElement(itemsList, e.clientY);
                const draggable = document.querySelector('.list-item.dragging');
                if (draggable) {
                    if (afterElement == null) {
                        itemsList.appendChild(draggable);
                    } else {
                        itemsList.insertBefore(draggable, afterElement);
                    }
                }
            });

            itemsList.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedElement) {
                    updateItemPositions();
                    saveData();
                }
            });
        }
        
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.list-group-item:not(.dragging), .list-item:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // CRUD Functions
        function addList(name) {
            const newId = todoData.lists.length > 0 ? Math.max(...todoData.lists.map(l => l.id), 0) + 1 : 1;
            // Shift existing lists' positions up
            todoData.lists.forEach(list => list.position += 1);
            // Add new list at position 1
            todoData.lists.push({ id: newId, name, position: 1 });
            sortData();
            renderListsMenu();
            saveData();
            switchToList(newId);
        }

        function deleteList(id) {
            if (confirm('Are you sure you want to delete this list and all its items?')) {
                todoData.lists = todoData.lists.filter(list => list.id !== id);
                todoData.items = todoData.items.filter(item => item.list_id !== id);
                renumberLists();
                renumberItems();
                renderListsMenu();
                saveData();
                if (currentListId === id) {
                    if (todoData.lists.length > 0) {
                        switchToList(todoData.lists[0].id);
                    } else {
                        headerListName.textContent = '';
                        itemsList.innerHTML = '';
                    }
                }
            }
        }

        function editList(id, newName) {
            const list = todoData.lists.find(l => l.id === id);
            if (list) {
                list.name = newName;
                renderListsMenu();
                saveData();
                if (currentListId === id) {
                    headerListName.textContent = `${newName} ðŸ“`;
                }
            }
        }

        function addItem(listId, text) {
            const newId = todoData.items.length > 0 ? Math.max(...todoData.items.map(i => i.id), 0) + 1 : 1;
            const listItems = todoData.items.filter(item => item.list_id === listId);
            const newPosition = listItems.length > 0 ? Math.max(...listItems.map(i => i.position)) + 1 : 1;
            todoData.items.push({ id: newId, list_id: listId, text, position: newPosition });
            sortData();
            renderItems(listId);
            saveData();
        }

        function deleteItem(id) {
            todoData.items = todoData.items.filter(item => item.id !== id);
            renumberItems();
            renderItems(currentListId);
            saveData();
        }

        function editItem(id, newText) {
            const item = todoData.items.find(i => i.id === id);
            if (item) {
                item.text = newText;
                renderItems(currentListId);
                saveData();
            }
        }

        // Update positions of lists after a drag and drop action
        function updateListPositions() {
            const reorderedListElements = Array.from(listsMenu.querySelectorAll('.list-group-item'));
            reorderedListElements.forEach((el, index) => {
                const listId = parseInt(el.dataset.listId);
                const listToUpdate = todoData.lists.find(list => list.id === listId);
                if (listToUpdate) {
                    listToUpdate.position = index + 1;
                }
            });
            sortData();
            renderListsMenu();
            saveData();
        }

        // Update positions of items after a drag and drop action
        function updateItemPositions() {
            const reorderedItemElements = Array.from(itemsList.querySelectorAll('.list-item'));
            reorderedItemElements.forEach((el, index) => {
                const itemId = parseInt(el.dataset.itemId);
                const itemToUpdate = todoData.items.find(item => item.id === itemId);
                if (itemToUpdate) {
                    itemToUpdate.position = index + 1;
                }
            });
            renumberItems();
            sortData();
            renderItems(currentListId);
            saveData();
        }

        // Re-number positions of lists after a change
        function renumberLists() {
            todoData.lists.forEach((list, index) => {
                list.position = index + 1;
            });
        }
        
        // Re-number positions of items after a change
        function renumberItems() {
            const listIds = todoData.lists.map(l => l.id);
            listIds.forEach(listId => {
                const itemsInList = todoData.items.filter(item => item.list_id === listId).sort((a, b) => a.position - b.position);
                itemsInList.forEach((item, index) => {
                    item.position = index + 1;
                });
            });
        }

        // Export data as JSON file
        function exportData() {
            const dataStr = JSON.stringify(todoData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'todo_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Import data from JSON file
        function importData(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const importedData = JSON.parse(event.target.result);
                    // Simple validation for required structure
                    if (importedData.lists && importedData.items) {
                        todoData = importedData;
                        sortData();
                        renderListsMenu();
                        if (todoData.lists.length > 0) {
                            switchToList(todoData.lists[0].id);
                        } else {
                            headerListName.textContent = '';
                            itemsList.innerHTML = '';
                        }
                        saveData();
                        alert('Data imported successfully!');
                    } else {
                        alert('Invalid JSON file format. Please import a valid file.');
                    }
                } catch (error) {
                    alert('Failed to parse JSON file.');
                }
            };
            reader.readAsText(file);
        }

        // Initial setup
        document.addEventListener('DOMContentLoaded', () => {
            loadData();
            addEventListeners();
        });
    </script>
</body>
</html>